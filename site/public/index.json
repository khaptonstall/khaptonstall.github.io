[{"content":"Problem Using Automatic Signing in Xcode 15.4, I received a ‚ÄúFailed Registering Bundle Identifier‚Äù error when I went to go add a new Capability for one of my Targets:\nWhile the error message states:\nThe app identifier ‚Äú‚Ä¶‚Äù cannot be registered to your development team because it is not available. Change your bundle identifier to a unique string to try again.\nthe app identifier (Bundle Identifier) was already registered under my account in App Store Connect, and signing was previously working prior to adding a new Capability (which updates the Provisioning Profile).\nSolution The solution was to prefix my Bundle Identifier in Xcode with my Apple Developer Team ID (which can be found at https://developer.apple.com/account under Membership Details).\n","permalink":"http://localhost:1313/posts/fix-failed-registering-bundle-identifier-error-with-automatic-signing-in-xcode-15/","summary":"\u003ch1 id=\"problem\"\u003eProblem\u003c/h1\u003e\n\u003cp\u003eUsing Automatic Signing in Xcode 15.4, I received a ‚ÄúFailed Registering Bundle Identifier‚Äù error when I went to go add a new Capability for one of my Targets:\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"failed-registering-bundle-identifier-error.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eWhile the error message states:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eThe app identifier ‚Äú‚Ä¶‚Äù cannot be registered to your development team because it is not available.\u003c/strong\u003e Change your bundle identifier to a unique string to try again.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ethe app identifier (Bundle Identifier) was already registered under my account in App Store Connect, and signing was previously working prior to adding a new Capability (which updates the Provisioning Profile).\u003c/p\u003e","title":"Fix Failed Registering Bundle Identifier Error with Automatic Signing in Xcode 15"},{"content":"Overview At time of writing, the Share Extension has yet to be given the SwiftUI overhaul that other Target-types have received, so you‚Äôll be met with a UIKit setup and Storyboard interface upon initial creation.\nIf you‚Äôre like me and want to leverage SwiftUI wherever possible, this article will show you how to do just that for your Share Extensions üëá\nShare Extension Setup The sections below will walk you through setting up a brand new Share Extension in your app. If you‚Äôve already got one setup, feel free to jump down to SwiftUI Conversion.\nCreating a Share Extension Following this guide requires you have a Share Extension to work from. Follow the steps below if you have yet to create one:\nIn Xcode, select File ‚Üí New ‚Üí Target Find the Share Extension target and select Next Provide a name for your Share Extension target If prompted, go ahead and activate the Scheme for the Share Extension At this point you should now have a Share Extension target with the following files:\nShareViewController.swift (a subclass of SLComposeServiceViewController) MainInterface.storyboard Info.plist Running the Share Extension To see your Share Extension in action:\nBuild + Run your Share Extension scheme to a simulator When prompted for an app to run in, select Safari Open any webpage and tap Safari‚Äôs Share button Select your app as the target for the shared content SwiftUI Conversion Removing the Storyboard Interface To kick things off, we‚Äôll remove the Storyboard file and update the Info.plist to point directly to the ShareViewController class as the entry point for the Share Extension:\nDelete MainIterface.storyboard Make the following updates to Info.plist: Delete the entry for NSExtensionMainStoryboard Add a new entry in its place with the key NSExtensionPrincipalClass and the value \u0026lt;TargetName\u0026gt;.ShareViewController Replace \u0026lt;TargetName\u0026gt; with the actual name of your Share Extension target Build + Run your Share Extension scheme to a simulator to ensure the behavior has not changed Present a SwiftUI View Now we‚Äôll update the existing ShareViewController to start presenting a SwiftUI view:\nUpdate ShareViewController to remove the inheritance of SLComposeServiceViewController and replace it with UIViewController Create a SwiftUI view that will be the main interface of your Share Extension Load the SwiftUI view in a UIHostingController and add it to your UIViewController on viewDidLoad // MARK: - SwiftUI Interface struct ShareView: View { var body: some View { Text(\u0026#34;Hello, World!\u0026#34;) } } // MARK: - UIKit Interface class ShareViewController: UIViewController { // MARK: Lifecycle override func viewDidLoad() { super.viewDidLoad() guard let extensionContext else { // Exit if we weren\u0026#39;t provided a context to work with return } setupShareView(with: extensionContext) } private func setupShareView(with context: NSExtensionContext) { // Wrap the SwiftUI view in a Hosting Controller let contentView = UIHostingController( rootView: ShareView() ) // Add the SwiftUI view as a child of ShareViewController addChild(contentView) view.addSubview(contentView.view) // Pin the child view to its parent contentView.view.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ contentView.view.topAnchor.constraint(equalTo: view.topAnchor), contentView.view.bottomAnchor.constraint(equalTo: view.bottomAnchor), contentView.view.leadingAnchor.constraint(equalTo: view.leadingAnchor), contentView.view.trailingAnchor.constraint(equalTo: view.trailingAnchor), ]) } } When you build and run your Share Extension now, you should see the following when sharing a webpage.\nCongrats, you‚Äôve got SwiftUI up and running in a Share Extension! üéâ\nFeel free to stop here and customize your view to fit your needs, but if you‚Äôd like to continue, I‚Äôll walk through replicating a similar UI to that of SLComposeServiceViewController where we pull metadata from the URL and display it to the user. ‚¨áÔ∏è\nDisplay URL Metadata in your SwiftUI Share Extension Below I‚Äôll walk you through the steps needed to pull metadata from a URL that was shared with your Share Extension and display it back to the user. The final result will be the following:\nApp Extension Utilities Working with NSExtensionContext and NSItemProvider can be fairly verbose, so I‚Äôve created a couple helper extensions that we can use to extract the URL and image from the webpage shared with our Share Extension.\nimport Foundation import UniformTypeIdentifiers // MARK: - App Extension Utilities enum ShareExtensionError: Error { case noAttachmentsMatchingType(UTType) case itemTypecastFailed(UTType) } extension NSExtensionContext { /// Attempts extracting the first attachment from the current context /// that matches the provided Uniform Type. func firstAttachment(ofType type: UTType) throws -\u0026gt; NSItemProvider { guard let firstItem = inputItems.first as? NSExtensionItem, let attachments = firstItem.attachments, let attachment = attachments.first(where: { $0.hasItemConformingToTypeIdentifier(type.identifier) }) else { throw ShareExtensionError.noAttachmentsMatchingType(type) } return attachment } } extension NSItemProvider { func loadURL() async throws -\u0026gt; URL { let uniformType = UTType.url let loadedItem = try await loadItem(forTypeIdentifier: uniformType.identifier) guard let url = loadedItem as? URL else { throw ShareExtensionError.itemTypecastFailed(uniformType) } return url } func loadImage() async throws -\u0026gt; UIImage { let uniformType = UTType.image // Make image loading async by wrapping the loadDataRepresentation(for:) // API with withCheckedThrowingContinuation return try await withCheckedThrowingContinuation { continuation in _ = loadDataRepresentation(for: uniformType) { imageData, error in if let error { continuation.resume(throwing: error) } else if let imageData, let image = UIImage(data: imageData) { continuation.resume(returning: image) } else { continuation.resume(throwing: ShareExtensionError.itemTypecastFailed(uniformType)) } } } } } Configuring the SwiftUI View to Display Webpage Metadata Next we‚Äôll configure the SwiftUI view to fetch metadata from the provided URL, populate the metadata in the UI, and provide Cancel and Save actions for the user, similar to the previous SLComposeServiceViewController:\nimport LinkPresentation import SwiftUI // MARK: - SwiftUI Interface struct ShareView: View { @State private var text: String = \u0026#34;\u0026#34; @State private var previewImage: Image? let context: NSExtensionContext var body: some View { NavigationStack { HStack(alignment: .top) { // We\u0026#39;ll try auto-populating the TextEditor with the webpage // title, but allow the user to change that as needed. TextEditor(text: $text) if let previewImage { previewImage .resizable() .frame(width: 80, height: 50) .aspectRatio(contentMode: .fill) .cornerRadius(8) .shadow(radius: 10) } } .padding(.horizontal) .toolbar { // Setup a navigation bar that mirrors // SLComposeServiceViewController ToolbarItem(placement: .cancellationAction) { Button(\u0026#34;Cancel\u0026#34;, action: cancelAction) } ToolbarItem(placement: .confirmationAction) { Button(\u0026#34;Save\u0026#34;, action: saveAction) } } .task { // Start loading webpage metadata before the view appears do { try await loadWebpageMetadata(for: context) } catch { print(error) } } } } // MARK: Button Actions private func cancelAction() { enum ShareError: Error { case userCancelled } context.cancelRequest(withError: ShareError.userCancelled) } private func saveAction() { // Return an array of results ([NSExtensionItem]) to the host app context.completeRequest(returningItems: []) } // MARK: Networking private func loadWebpageMetadata( for context: NSExtensionContext ) async throws { // Use previously defined extensions to extract the URL // from the extension context: let url = try await context.firstAttachment(ofType: .url).loadURL() // Use Apple\u0026#39;s LPMetadataProvider API to extract metadata from the URL: let linkMetadataProvider = LPMetadataProvider() let metadata = try await linkMetadataProvider.startFetchingMetadata(for: url) // Once we extract the metadata, update the UI with available info if let webpageTitle = metadata.title { text = webpageTitle } if let imageProvider = metadata.imageProvider, let linkPreviewImage = try? await imageProvider.loadImage() { previewImage = Image(uiImage: linkPreviewImage) } } } The final step (which the compiler should already be complaining about) is to pass the extension context into your SwiftUI view:\nclass ShareViewController: UIViewController { private func setupShareView(with context: NSExtensionContext) { let contentView = UIHostingController( rootView: ShareView(context: context) ) ... } } Build and Run your Share Extension again to start seeing webpage metadata populated in SwiftUI! üöÄ\nAdditional Resources As you continue building our your Share Extension, check out these Apple Developer resources:\nApple: Share Extension Overview App Extension Programming Guide: Declaring Supported Data Types ","permalink":"http://localhost:1313/posts/building-a-share-extension-with-swiftui/","summary":"\u003ch1 id=\"overview\"\u003eOverview\u003c/h1\u003e\n\u003cp\u003eAt time of writing, the Share Extension has yet to be given the SwiftUI overhaul that other Target-types have received, so you‚Äôll be met with a UIKit setup and Storyboard interface upon initial creation.\u003c/p\u003e\n\u003cp\u003eIf you‚Äôre like me and want to leverage SwiftUI wherever possible, this article will show you how to do just that for your Share Extensions üëá\u003c/p\u003e\n\u003ch1 id=\"share-extension-setup\"\u003eShare Extension Setup\u003c/h1\u003e\n\u003cp\u003eThe sections below will walk you through setting up a brand new Share Extension in your app. If you‚Äôve already got one setup, feel free to jump down to SwiftUI Conversion.\u003c/p\u003e","title":"Building a Share Extension with SwiftUI"},{"content":"This post will outline a process of checking Xcode Code Snippets into source control in order to build out a library of snippets you can easily import on new machines or take with you to new companies. (You can also use this to create a shared library of snippets within a development team.)\nI won‚Äôt go over how to create and use code snippets within Xcode, but if you‚Äôd like a refresher, check out this post by Sarun.\nSetup Create a code snippets repository First, you‚Äôll need to have a repository setup in which you‚Äôll store your code snippets. We‚Äôll assume that‚Äôs done and that we‚Äôll store all snippets within the root of that repository.\nSave your first snippet We‚Äôll also need a code snippet to work with. For demo purposes, I‚Äôll use the one below, which contains some boilerplate to create a new EnvironmentKey in SwiftUI:\n\u0026amp;lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026amp;gt; \u0026amp;lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026amp;gt; \u0026amp;lt;plist version=\u0026#34;1.0\u0026#34;\u0026amp;gt; \u0026amp;lt;dict\u0026amp;gt; \u0026amp;lt;key\u0026amp;gt;IDECodeSnippetCompletionPrefix\u0026amp;lt;/key\u0026amp;gt; \u0026amp;lt;string\u0026amp;gt;environmentkey\u0026amp;lt;/string\u0026amp;gt; \u0026amp;lt;key\u0026amp;gt;IDECodeSnippetCompletionScopes\u0026amp;lt;/key\u0026amp;gt; \u0026amp;lt;array\u0026amp;gt; \u0026amp;lt;string\u0026amp;gt;TopLevel\u0026amp;lt;/string\u0026amp;gt; \u0026amp;lt;/array\u0026amp;gt; \u0026amp;lt;key\u0026amp;gt;IDECodeSnippetContents\u0026amp;lt;/key\u0026amp;gt; \u0026amp;lt;string\u0026amp;gt;private struct \u0026amp;amp;lt;#Key#\u0026amp;amp;gt;: EnvironmentKey { static let defaultValue: \u0026amp;amp;lt;#Type#\u0026amp;amp;gt; = \u0026amp;amp;lt;#Default Value#\u0026amp;amp;gt; } extension EnvironmentValues { var \u0026amp;amp;lt;#name#\u0026amp;amp;gt;: \u0026amp;amp;lt;#Type#\u0026amp;amp;gt; { get { self[\u0026amp;amp;lt;#Key#\u0026amp;amp;gt;.self] } set { self[\u0026amp;amp;lt;#Key#\u0026amp;amp;gt;.self] = newValue } } }\u0026amp;lt;/string\u0026amp;gt; \u0026amp;lt;key\u0026amp;gt;IDECodeSnippetIdentifier\u0026amp;lt;/key\u0026amp;gt; \u0026amp;lt;string\u0026amp;gt;8DBC6F81-7661-48B5-B852-2336988AB94C\u0026amp;lt;/string\u0026amp;gt; \u0026amp;lt;key\u0026amp;gt;IDECodeSnippetLanguage\u0026amp;lt;/key\u0026amp;gt; \u0026amp;lt;string\u0026amp;gt;Xcode.SourceCodeLanguage.Swift\u0026amp;lt;/string\u0026amp;gt; \u0026amp;lt;key\u0026amp;gt;IDECodeSnippetSummary\u0026amp;lt;/key\u0026amp;gt; \u0026amp;lt;string\u0026amp;gt;\u0026amp;lt;/string\u0026amp;gt; \u0026amp;lt;key\u0026amp;gt;IDECodeSnippetTitle\u0026amp;lt;/key\u0026amp;gt; \u0026amp;lt;string\u0026amp;gt;EnvironmentKey\u0026amp;lt;/string\u0026amp;gt; \u0026amp;lt;key\u0026amp;gt;IDECodeSnippetUserSnippet\u0026amp;lt;/key\u0026amp;gt; \u0026amp;lt;true/\u0026amp;gt; \u0026amp;lt;key\u0026amp;gt;IDECodeSnippetVersion\u0026amp;lt;/key\u0026amp;gt; \u0026amp;lt;integer\u0026amp;gt;0\u0026amp;lt;/integer\u0026amp;gt; \u0026amp;lt;/dict\u0026amp;gt; \u0026amp;lt;/plist\u0026amp;gt; And here‚Äôs the Swift code the above code snippet will generate:\nprivate struct \u0026lt;#Key#\u0026gt;: EnvironmentKey { static let defaultValue: \u0026lt;#Type#\u0026gt; = \u0026lt;#Default Value#\u0026gt; } extension EnvironmentValues { var \u0026lt;#name#\u0026gt;: \u0026lt;#Type#\u0026gt; { get { self[\u0026lt;#Key#\u0026gt;.self] } set { self[\u0026lt;#Key#\u0026gt;.self] = newValue } } } Copy the XML code snippet from above and save it as a new file within the root directory of your repo with the extension .codesnippet (e.g. environment-key.codesnippet).\nLoad Your Custom Code Snippets To make your code snippets available to Xcode, you‚Äôll need to move them into the CodeSnippets directory, found at ~/Library/Developer/Xcode/UserData/CodeSnippets.\nBelow is a script you can create and store in your code snippets repo to help automate the process:\n#!/bin/bash # Store the Xcode CodeSnippets directory into a variable we can reference SNIPPETS_DIRECTORY=\u0026#34;$HOME/Library/Developer/Xcode/UserData/CodeSnippets\u0026#34; # Find all .codesnippet files within the current directory and # store them in a variable SNIPPETS=$(find ./ -type f -name \u0026#39;*.codesnippet\u0026#39;) # For each .codesnippet file, copy it into the snippets directory echo \u0026#34;$SNIPPETS\u0026#34; | xargs -I {} cp {} $SNIPPETS_DIRECTORY As you continue working in Xcode and find yourself typing the same boilerplate, you can create Xcode Code Snippets and pull them from the CodeSnippets directory into your own repo. Then, when you jump to a new machine, simply clone your repo and run the script above! üéâ\nThere‚Äôs also opportunity here to create a script which does the reverse (i.e. pulls all the snippets out of the CodeSnippets directory and into your repo), but I‚Äôll leave that as an exercise to the reader üßë‚Äçüíª.\n","permalink":"http://localhost:1313/posts/building-a-repository-of-xcode-code-snippets/","summary":"\u003cp\u003eThis post will outline a process of checking Xcode Code Snippets into source control in order to build out a library of snippets you can easily import on new machines or take with you to new companies. (You can also use this to create a shared library of snippets within a development team.)\u003c/p\u003e\n\u003cp\u003eI won‚Äôt go over how to create and use code snippets \u003cem\u003ewithin\u003c/em\u003e Xcode, but if you‚Äôd like a refresher, check out \u003ca href=\"https://sarunw.com/posts/how-to-create-code-snippets-in-xcode/\"\u003ethis post by Sarun\u003c/a\u003e.\u003c/p\u003e","title":"Building a Repository of Xcode Code Snippets"},{"content":"I recently decided to update my personal home page (a simple one-page HTML site using Jekyll) to try out Ignite, as I‚Äôd much prefer to maintain a Swift package over working directly with HTML.\nIgnite is an open-source static site builder for Swift developers, created by Paul Hudson.\nWhile working with Ignite is fairly straightforward, and there are plenty of excellent examples provided in the IgniteSamples repo, I ran into a couple speed bumps deploying via GitHub Pages.\nBelow, I‚Äôll walk you through the steps to get your own static site up and running using Ignite and GitHub Pages.\nPrerequisites This guide expects you to already be familiar with Git, Swift and SPM. Also, you should have followed the steps to setup a personal GitHub Page using GitHub‚Äôs own documentation and have that repo cloned locally.\nIn doing so, you should be able to visit github-username.github.io and see a basic HTML page (replacing github-username with your own).\nSetting up your Ignite home page The simplest way to get started is to download the IgniteStarter project.\nAdd the contents of this project to the root directory of your personal GitHub Page repo you cloned locally.\nSince this is a Swift Package, open the contents in Xcode and open the Site.swift file. Inside, change the value url property to match the url of your personal Github Page:\nstruct ExampleSite: Site { var url = URL(\u0026#34;github-username.github.io\u0026#34;) } Once updated, build and run the IgniteStarter scheme in Xcode. This should generate a new Build/ folder in your project and at the top level should be an index.html file representing your home page.\nRunning your website locally Before deploying to GitHub Pages, verify that you can run your website locally. In your terminal, navigate into the Build/ directory generated by Ignite and run the following:\npython3 -m http.server The output of this command should include the port your local web server is running on (e.g. 8000). In your web browser, navigate to http://localhost:port and verify you can view your page.\nDeploying to GitHub Pages By default, GitHub Pages only deploys from either the root of a branch, or from a docs/ folder. Since our site live in the Build/ directory, there are a couple steps to take before successfully deploying to GitHub Pages:\nRemove the index.html file from the root of your directory that you created when first setting up your GitHub Page\nOpen your .gitignore and remove the Build directory\nIn your GitHub Page repo, navigate to Settings ‚Üí Pages ‚Üí Build and deployment. Use the Source dropdown to switch from Deploy from a branch to GitHub Actions\nBack in your terminal, in the root of your project, prepare a new workflow to deploy your page\nmkdir -p .github/workflows \u0026amp;\u0026amp; touch .github/workflows/static.yml Open static.yml and paste the following, changing your default branch as necessary a. The important piece here is in the Upload artifact step. Instead of defaulting to the root directory, we‚Äôre pointing at the Build directory that contains our home page\n# Simple workflow for deploying static content to GitHub Pages name: Deploy static content to Pages on: # Runs on pushes targeting the default branch push: branches: [\u0026#34;main\u0026#34;] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false jobs: # Single deploy job since we\u0026#39;re just deploying deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Setup Pages uses: actions/configure-pages@v5 - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: \u0026#39;./Build\u0026#39; - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 Push your changes up to GitHub and, once the deployment completes, visit your new Ignite-driven home page üéâ\n","permalink":"http://localhost:1313/posts/building-a-static-site-in-swift-using-ignite-and-github-pages/","summary":"\u003cp\u003eI recently decided to update my personal home page (a simple one-page HTML site using Jekyll) to try out Ignite, as I‚Äôd much prefer to maintain a Swift package over working directly with HTML.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/twostraws/Ignite\"\u003eIgnite\u003c/a\u003e is an open-source static site builder for Swift developers, created by \u003ca href=\"https://twitter.com/twostraws\"\u003ePaul Hudson\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWhile working with Ignite is fairly straightforward, and there are plenty of excellent examples provided in the \u003ca href=\"https://github.com/twostraws/IgniteSamples\"\u003eIgniteSamples\u003c/a\u003e repo, I ran into a couple speed bumps deploying via \u003ca href=\"https://pages.github.com\"\u003eGitHub Pages\u003c/a\u003e.\u003c/p\u003e","title":"Building a Static Site in Swift using Ignite and GitHub Pages"}]